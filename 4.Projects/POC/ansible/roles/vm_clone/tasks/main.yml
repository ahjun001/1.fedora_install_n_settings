---
# roles/vm_clone/tasks/main.yml
# Handle thin clone creation, conversion to full images, and manifest updates

- name: Create thin clone from backing image
  ansible.builtin.shell: |
    qemu-img create -f qcow2 \
      -b "{{ clone_backing_image }}" \
      "{{ clone_dest_path }}/{{ clone_name }}"
  args:
    executable: /bin/bash
  register: thin_clone_result
  when: clone_is_full is not defined or not clone_is_full

- name: Register thin clone domain in libvirt
  ansible.builtin.shell: |
    virsh define /dev/stdin << EOF
    <domain type='kvm'>
      <name>{{ clone_domain_name }}</name>
      <memory unit='MiB'>{{ clone_memory }}</memory>
      <currentMemory unit='MiB'>{{ clone_memory }}</currentMemory>
      <vcpu placement='static'>{{ clone_vcpus }}</vcpu>
      <os>
        <type arch='x86_64' machine='pc'>hvm</type>
        <boot dev='hd'/>
      </os>
      <devices>
        <emulator>/usr/bin/qemu-system-x86_64</emulator>
        <disk type='file' device='disk'>
          <driver name='qemu' type='qcow2'/>
          <source file='{{ clone_dest_path }}/{{ clone_name }}'/>
          <target dev='vda' bus='virtio'/>
        </disk>
        <interface type='network'>
          <source network='default'/>
          <model type='virtio'/>
        </interface>
        <console type='pty'>
          <target type='virtio'/>
        </console>
        <graphics type='spice' listen='0.0.0.0'/>
      </devices>
    </domain>
    EOF
  when: thin_clone_result is changed

- name: Convert thin clone to full independent image
  ansible.builtin.shell: |
    qemu-img convert -O qcow2 \
      "{{ clone_dest_path }}/{{ clone_src_name }}" \
      "{{ clone_dest_path }}/{{ clone_name }}"
  args:
    executable: /bin/bash
  register: convert_result
  when: clone_is_full is defined and clone_is_full

- name: Load per-VM image manifest
  ansible.builtin.include_vars:
    file: "{{ playbook_dir }}/vars/vm_images.d/{{ vm_name }}.yml"
    name: vm_image_data
  when: clone_track_artifact is not defined or clone_track_artifact

- name: Build new artifact entry
  ansible.builtin.set_fact:
    new_artifact:
      name: "{{ clone_name }}"
      stage: "{{ clone_stage }}"
      backing_image: "{{ clone_backing_image | default(omit) }}"
      is_full_image: "{{ (clone_is_full | default(false)) | bool }}"
      created: "{{ ansible_date_time.iso8601 }}"
      description: "{{ clone_description | default('') }}"
  when: clone_track_artifact is not defined or clone_track_artifact

- name: Build updated VM image config with new artifact
  ansible.builtin.set_fact:
    updated_vm_config: >-
      {{
        vm_image_data | combine({
          vm_name + '_image_config': (
            vm_image_data[vm_name + '_image_config'] |
            combine({
              'artifacts': (vm_image_data[vm_name + '_image_config'].artifacts | default([])) + [ new_artifact ]
            })
          )
        })
      }}
  when: clone_track_artifact is not defined or clone_track_artifact

- name: Write updated per-VM manifest
  ansible.builtin.copy:
    dest: "{{ playbook_dir }}/vars/vm_images.d/{{ vm_name }}.yml"
    content: |
      ---
      # vars/vm_images.d/{{ vm_name }}.yml
      # Workflow manifest for {{ vm_name }} VM

      {{ (updated_vm_config | to_nice_yaml) }}
  register: manifest_update
  when: clone_track_artifact is not defined or clone_track_artifact
